

## 1) Project types and where to run `mvn`

* Run Maven commands from the **project root** where `pom.xml` lives:

```bash
cd /path/to/my-project
mvn clean package
```

Two common Maven project outputs:

* **JAR** (standalone Java app or Spring Boot) → runnable with `java -jar`.
* **WAR** (Java webapp) → deployed in servlet container (Tomcat/Jetty) or run inside a Tomcat image.

---

## 2) Minimal project structures

### JAR app (console or Spring Boot)

```
my-project/
├── src/main/java/com/example/App.java
├── pom.xml   # packaging: jar (default)
```

### Web app (WAR) with JSP

```
my-web-project/
├── src/main/java/           # servlets, optional
├── src/main/webapp/index.jsp
├── src/main/webapp/WEB-INF/web.xml
└── pom.xml   # <packaging>war</packaging>
```

---

## 3) Important `pom.xml` snippets

### A. JAR with main class (use maven-jar-plugin)

```xml
<build>
  <plugins>
    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-compiler-plugin</artifactId>
      <version>3.10.1</version>
      <configuration>
        <source>17</source>
        <target>17</target>
      </configuration>
    </plugin>

    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-jar-plugin</artifactId>
      <version>3.3.0</version>
      <configuration>
        <archive>
          <manifest>
            <mainClass>com.example.App</mainClass>
          </manifest>
        </archive>
      </configuration>
    </plugin>
  </plugins>
</build>
```

> If you use Spring Boot, prefer `spring-boot-maven-plugin` which produces executable fat JARs.

### B. WAR packaging (web app)

```xml
<packaging>war</packaging>

<dependencies>
  <dependency>
    <groupId>jakarta.servlet</groupId>
    <artifactId>jakarta.servlet-api</artifactId>
    <version>5.0.0</version>
    <scope>provided</scope>
  </dependency>
</dependencies>

<build>
  <plugins>
    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-war-plugin</artifactId>
      <version>3.3.2</version>
    </plugin>
  </plugins>
</build>
```

---

## 4) Minimal example sources

### A. Main.java (JAR)

```java
package com.example;
public class App {
    public static void main(String[] args) {
        System.out.println("Hello from App");
    }
}
```

### B. index.jsp (WAR)

```
src/main/webapp/index.jsp
```

```jsp
<%@ page contentType="text/html;charset=UTF-8" %>
<!DOCTYPE html>
<html>
<head><title>Hello</title></head>
<body>
  <h1>Hello World — JSP</h1>
</body>
</html>
```

### C. WEB-INF/web.xml (minimal)

```xml
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         version="3.1">
    <welcome-file-list>
        <welcome-file>index.jsp</welcome-file>
    </welcome-file-list>
</web-app>
```

---

## 5) Build with Maven (commands)

From project root (where `pom.xml` is):

```bash
# fresh build (recommended)
mvn clean package

# or build + install to local repo
mvn clean install

# run tests only
mvn test
```

After `package`, your artifact will be in `target/`:

* JAR: `target/<artifactId>-<version>.jar`
* WAR: `target/<artifactId>-<version>.war`

---

## 6) Initialize Git and push to GitHub (commands)

```bash
git init
# create .gitignore before committing (see .gitignore example below)
git add .
git commit -m "Initial commit"

git remote add origin https://github.com/your-username/your-repo.git
git branch -M main
git push -u origin main
```

`.gitignore` minimal (to add before `git add`):

```
# Maven
target/
!target/*.jar

# OS / IDE
*.log
*.class
*.iml
.idea/
.vscode/

# Docker
.dockerignore
```

---

## 7) Create Dockerfile

Place `Dockerfile` at project root. Two common variants below.

### A) JAR app — multi-stage (recommended)

```dockerfile
# Build stage
FROM maven:3.9.0-eclipse-temurin-17 AS build
WORKDIR /app
COPY . .
RUN mvn clean package -DskipTests

# Run stage
FROM eclipse-temurin:17-jre
WORKDIR /app
COPY --from=build /app/target/my-project.jar ./my-project.jar
EXPOSE 8080
CMD ["java","-jar","/app/my-project.jar"]
```

> Replace `my-project.jar` with the actual jar filename (artifactId-version.jar) or adjust the `COPY` path with a wildcard if necessary.

### B) WAR for Tomcat (two options)

**Option 1 — copy WAR into Tomcat image (simple)**

```dockerfile
FROM tomcat:9.0-jdk17
WORKDIR /usr/local/tomcat/webapps
# remove default ROOT if you want root context
RUN rm -rf ROOT
COPY target/my-web-project.war ./ROOT.war
EXPOSE 8080
CMD ["catalina.sh","run"]
```

**Option 2 — multi-stage build that builds then packages into Tomcat**

```dockerfile
FROM maven:3.9.0-eclipse-temurin-17 AS build
WORKDIR /app
COPY . .
RUN mvn clean package -DskipTests

FROM tomcat:9.0-jdk17
WORKDIR /usr/local/tomcat/webapps
RUN rm -rf ROOT
COPY --from=build /app/target/my-web-project.war ./ROOT.war
EXPOSE 8080
CMD ["catalina.sh","run"]
```

### .dockerignore (recommended)

```
target/
.git
.gitignore
**/*.log
*.md
.DS_Store
```

---

## 8) Build and run Docker image locally

```bash
# build (tag with name)
docker build -t yourusername/my-project:1.0 .

# run (map ports)
docker run -d -p 8080:8080 --name my-project-run yourusername/my-project:1.0

# check running containers
docker ps

# view logs
docker logs -f my-project-run

# stop and remove
docker stop my-project-run
docker rm my-project-run
```

---

## 9) Push to Docker Hub

```bash
# login
docker login

# tag (if not already tagged)
docker tag my-project-image yourusername/my-project:1.0

# push
docker push yourusername/my-project:1.0
```

### Verify: browse to `https://hub.docker.com/r/yourusername/my-project`

---

## 10) Share with others (commands for friend)

```bash
# pull
docker pull yourusername/my-project:1.0

# run
docker run -d -p 8080:8080 yourusername/my-project:1.0
```

They then open `http://localhost:8080/` or `http://localhost:8080/index.jsp` for a WAR.

---

## 11) Docker Compose

### A) When to use

* Use Compose to run multi-container setups (app + database + cache) or to simplify `docker run` commands.

### B) Minimal `docker-compose.yml` examples

**1) Compose building locally from Dockerfile (single service)**

```yaml
version: '3.8'
services:
  web:
    build: .
    image: yourusername/my-project:1.0
    ports:
      - "8080:8080"
    restart: unless-stopped
```

**2) Pull image from Docker Hub**

```yaml
version: '3.8'
services:
  web:
    image: yourusername/my-project:1.0
    ports:
      - "8080:8080"
    restart: unless-stopped
```

**3) Web app + MySQL example**

```yaml
version: '3.8'
services:
  web:
    image: yourusername/my-project:1.0
    ports:
      - "8080:8080"
    environment:
      - SPRING_DATASOURCE_URL=jdbc:mysql://db:3306/mydb
    depends_on:
      - db

  db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: rootpw
      MYSQL_DATABASE: mydb
      MYSQL_USER: user
      MYSQL_PASSWORD: pass
    volumes:
      - db-data:/var/lib/mysql

volumes:
  db-data:
```

### C) Compose commands

```bash
# run in background
docker compose up -d

# rebuild images and recreate containers
docker compose up -d --build

# view logs
docker compose logs -f

# list containers
docker compose ps

# stop and remove containers, networks
docker compose down
```

---

## 12) Useful tips & best practices

* Use **multi-stage builds** to keep images small.
* Add a `.dockerignore` to avoid copying target, .git, node\_modules, etc.
* Tag images with semantic tags: `v1.0`, `sha-abc123`, `latest`.
* Use `healthcheck` in Dockerfile or compose to let orchestrators know when the container is ready.
* Keep secrets out of Dockerfiles; use environment variables or secrets managers.
* For production, consider a minimal JVM runtime (e.g., Eclipse Temurin JRE) or native images.

**Example healthcheck** (in Dockerfile):

```dockerfile
HEALTHCHECK --interval=30s --timeout=5s --start-period=10s CMD curl -f http://localhost:8080/ || exit 1
```

---

## 13) Common troubleshooting

* **`No main manifest attribute`** → set `Main-Class` via `maven-jar-plugin` or use `spring-boot-maven-plugin` to create an executable JAR.
* **`Cannot access defaults field of Properties` / old maven-war-plugin** → upgrade `maven-war-plugin` to `3.x` in `pom.xml`.
* **Docker error: pipe not found (Windows)** → Docker Desktop not running. Start Docker Desktop.
* **LF/CRLF warnings** → add `target/` to `.gitignore` and consider `git config core.autocrlf true` on Windows.
* **Port already in use** → change host port mapping (e.g., `-p 8081:8080`).

---

## 14) Quick checklist (one-liners)

```bash
# build with maven
mvn clean package

# build docker image
docker build -t yourusername/my-project:1.0 .

# run container
docker run -d -p 8080:8080 yourusername/my-project:1.0

# push to hub
docker login
docker push yourusername/my-project:1.0

# docker compose up
docker compose up -d --build
```


